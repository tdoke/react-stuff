1] custom hook work exactly like react component, 
but it does not have 'return (<>jsx markup</>)', it can return values, objects.
2] you add a stateful logic to a custom hook, and reuse it across multiple components.
3] Custom Hooks let you share stateful logic, not state itself 
In the earlier example, when you turned the network on and off, both components 
updated together. However, it’s wrong to think that a single isOnline state variable is 
shared between them. Look at this code:

function StatusBar() {
  const isOnline = useOnlineStatus();
  // ...
}

function SaveButton() {
  const isOnline = useOnlineStatus();
  // ...
}
It works the same way as before you extracted the duplication:

function StatusBar() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    // ...
  }, []);
  // ...
}

function SaveButton() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    // ...
  }, []);
  // ...
}
These are two completely independent state variables and Effects! They happened to have 
the same value at the same time because you synchronized them with 
the same external value (whether the network is on).
4] Custom Hooks let you share stateful logic but not state itself. Each call to a Hook 
is completely independent from every other call to the same Hook. This is why the two 
sandboxes above are completely equivalent. If you’d like, scroll back up and compare them. 
The behavior before and after extracting a custom Hook is identical.

When you need to share the state itself between multiple components, lift it up 
and pass it down instead.


